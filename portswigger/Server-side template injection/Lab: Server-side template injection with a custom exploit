Exploiting Server-Side Template Injection via Method Invocation and File Manipulation

Lab Difficulty: Expert
Vulnerability Type: Server-Side Template Injection / Arbitrary File Access / Code Execution via Built-in Methods

Summary
This lab demonstrates a high-risk Server-Side Template Injection (SSTI) vulnerability where insecure template rendering permits access to backend user
objects and methods. Through careful manipulation, it is possible to invoke internal methods, read arbitrary files on the server, and ultimately 
delete a sensitive file from another user’s home directory. The lab simulates a real-world scenario where chaining method calls and abusing internal
logic can lead to critical impact.

Objective
Exploit SSTI via user-supplied data to:

Gain access to internal objects (user)

Abuse method invocation to read and delete files

Delete the file: /home/carlos/.ssh/id_rsa

Technical Walkthrough
1. Log in to the Application
Logged in using the provided test credentials:

Username: wiener  
Password: peter
Explored account settings and comments functionality.

2. Identify Template Injection Point
Navigated to “My Account” and updated the preferred name field with a template payload to test for SSTI:

{{7*7}}
The output rendered 49, confirming template expression evaluation and a server-side injection point.

3. Discover Internal User Object Access
Probed deeper with:

{{user}}
The response indicated access to the user object and exposed various methods, including a custom setAvatar() method.

4. Investigate Avatar Upload Mechanism
Uploaded an invalid file as an avatar.

Observed an error message revealing:

user.setAvatar(path, mime)
Noted that this method accepts a file path and MIME type as arguments.

Confirmed the file path /home/carlos/User.php from the error message.

5. Confirm Arbitrary File Read
To test setAvatar() behavior:

Injected via preferred name field:

{{user.setAvatar('/etc/passwd', 'image/jpg')}}
Viewed one of my blog comments (which renders the name field).

Requested:

GET /avatar?avatar=wiener
Received the contents of /etc/passwd, confirming arbitrary file read via setAvatar.

6. Read the User.php File
Repeated the process with:

{{user.setAvatar('/home/carlos/User.php','image/jpg')}}
Dumped contents via the avatar endpoint.

Found definition of user.gdprDelete() method, which deletes the currently set avatar file.

7. Weaponize to Delete Sensitive File
Chained method calls to delete Carlos’s SSH private key:

Step 1: Set the target file as the avatar

{{user.setAvatar('/home/carlos/.ssh/id_rsa','image/jpg')}}
Step 2: Invoke the delete method

{{user.gdprDelete()}}
Viewed the blog comment to trigger each method. The second request successfully deleted the file.

Result
The lab was marked “Solved” after the /home/carlos/.ssh/id_rsa file was confirmed deleted.

Root Cause
The application insecurely rendered user-controlled input in a server-side template context. Specifically:

Provided access to backend objects and their methods.

Failed to sandbox template rendering.

Allowed file operations (read/delete) via exposed method calls (setAvatar, gdprDelete).

Mitigation
To prevent such issues:

Never render user input directly in template logic.

Use safe contexts or template engines that sandbox execution.

Restrict access to backend objects and methods from the template context.

Validate avatar file paths and types server-side, disallowing absolute or sensitive paths.

Avoid exposing debug information that reveals file paths or backend method names.
